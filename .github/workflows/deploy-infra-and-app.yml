name: Provision & Deploy to DO

on:
  push:
    branches:
      - main

jobs:
  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          version: latest
      
      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v3
        with:
          context: .
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/bn-trading:latest
          cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/bn-trading:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/bn-trading:buildcache,mode=max

  terraform:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: build
    outputs:
      droplet_ip: ${{ steps.set_ip.outputs.DROPLET_IP }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Perform network diagnostics
        run: |
          # Make network_diagnostics.sh executable
          chmod +x ./network_diagnostics.sh
          
          echo "Running basic network diagnostics..."
          echo "DNS Servers:"
          cat /etc/resolv.conf
          
          echo "Testing connectivity to api.digitalocean.com:"
          ping -c 3 api.digitalocean.com || echo "Ping failed but continuing"
          
          echo "Testing DNS resolution:"
          nslookup api.digitalocean.com || echo "DNS lookup failed but continuing"
          
          echo "Testing HTTPS connectivity:"
          curl -sSL https://api.digitalocean.com/v2/account -o /dev/null -w "Response code: %{http_code}\n" || echo "HTTPS test failed but continuing"
          
          echo "Checking for proxy settings:"
          env | grep -i proxy || echo "No proxy settings found"
          
          echo "For more detailed diagnostics, run network_diagnostics.sh manually"
      
      - name: Terraform Init
        working-directory: infra
        run: |
          # Retry logic for terraform init
          MAX_ATTEMPTS=3
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i/$MAX_ATTEMPTS: Running terraform init..."
            if terraform init; then
              echo "✅ Terraform init succeeded!"
              break
            else
              echo "❌ Terraform init failed on attempt $i"
              if [ $i -eq $MAX_ATTEMPTS ]; then
                echo "All $MAX_ATTEMPTS attempts failed, stopping."
                exit 1
              else
                echo "Waiting 30 seconds before next attempt..."
                sleep 30
              fi
            fi
          done

      - name: Terraform Validate
        working-directory: infra
        run: |
          # Retry logic for terraform validate
          MAX_ATTEMPTS=3
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i/$MAX_ATTEMPTS: Running terraform validate..."
            if terraform validate; then
              echo "✅ Terraform validate succeeded!"
              break
            else
              echo "❌ Terraform validate failed on attempt $i"
              if [ $i -eq $MAX_ATTEMPTS ]; then
                echo "All $MAX_ATTEMPTS attempts failed, stopping."
                exit 1
              else
                echo "Waiting 10 seconds before next attempt..."
                sleep 10
              fi
            fi
          done

      - name: Check for existing droplet
        id: check_existing
        working-directory: infra
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}
        run: |
          # Check if there's already a droplet with our target name
          echo "Checking for existing droplet with name 'bn-trading-server'..."
          EXISTING_DROPLETS=$(curl -s -X GET \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $DIGITALOCEAN_TOKEN" \
            "https://api.digitalocean.com/v2/droplets?per_page=200" | \
            jq -r '.droplets[] | select(.name=="bn-trading-server")')
          
          if [ -n "$EXISTING_DROPLETS" ]; then
            # Get the first droplet if multiple exist
            echo "Found existing droplets with name 'bn-trading-server'. Using the first one."
            FIRST_DROPLET=$(echo "$EXISTING_DROPLETS" | head -n 1)
            DROPLET_ID=$(echo "$FIRST_DROPLET" | jq -r '.id')
            DROPLET_IP=$(echo "$FIRST_DROPLET" | jq -r '.networks.v4[] | select(.type=="public") | .ip_address' | head -n 1)
            
            echo "Selected droplet: ID=$DROPLET_ID, IP=$DROPLET_IP"
            echo "DROPLET_EXISTS=true" >> $GITHUB_OUTPUT
            echo "DROPLET_IP=$DROPLET_IP" >> $GITHUB_OUTPUT
            echo "DROPLET_ID=$DROPLET_ID" >> $GITHUB_OUTPUT
            
            # List all found droplets for information
            echo "All matching droplets:"
            echo "$EXISTING_DROPLETS" | jq -r '.id'
          else
            echo "No existing droplet found with name 'bn-trading-server'"
            echo "DROPLET_EXISTS=false" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Apply
        id: apply
        working-directory: infra
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}
        if: steps.check_existing.outputs.DROPLET_EXISTS != 'true'
        run: |
          # Configure SSH known hosts to avoid trust issues
          mkdir -p ~/.ssh
          ssh-keyscan -H digitalocean.com >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Install prerequisite packages
          echo "Installing prerequisite packages..."
          sudo apt-get update >/dev/null
          sudo apt-get install -y dnsutils jq curl >/dev/null || true
          
          # Set DNS servers explicitly if needed
          echo "Testing DNS resolution..."
          if ! nslookup api.digitalocean.com &>/dev/null; then
            echo "Primary DNS checks failed, trying Google DNS..."
            echo "nameserver 8.8.8.8" | sudo tee /etc/resolv.conf > /dev/null
            echo "nameserver 8.8.4.4" | sudo tee -a /etc/resolv.conf > /dev/null
            
            # Verify DNS servers were updated
            echo "Updated DNS configuration to:"
            cat /etc/resolv.conf
            
            # Test DNS resolution with new servers
            nslookup api.digitalocean.com || echo "Warning: DNS resolution still failing"
          fi
          
          # Verify SSH Key Exists in DigitalOcean
          echo "Verifying SSH Key exists in DigitalOcean..."
          SSH_KEY_EXISTS=$(curl -s -X GET \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.DIGITALOCEAN_TOKEN }}" \
            "https://api.digitalocean.com/v2/account/keys/${{ secrets.SSH_KEY_ID }}" | \
            jq -r '.ssh_key.id' 2>/dev/null)
          
          if [ "$SSH_KEY_EXISTS" == "${{ secrets.SSH_KEY_ID }}" ]; then
            echo "✅ SSH key verified in DigitalOcean account"
          else
            echo "⚠️ Warning: Could not verify SSH key ID ${{ secrets.SSH_KEY_ID }} in DigitalOcean"
            echo "Will continue anyway, but SSH access might fail"
          fi
          
          echo "Starting Terraform apply with retry logic..."
          MAX_ATTEMPTS=3
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i/$MAX_ATTEMPTS: Running terraform apply..."
            if terraform apply -auto-approve -var="digitalocean_token=${{ secrets.DIGITALOCEAN_TOKEN }}" -var="ssh_key_id=${{ secrets.SSH_KEY_ID }}"; then
              echo "✅ Terraform apply succeeded!"
              
              # Verify droplet was actually created by using the API directly
              echo "Verifying droplet creation using DO API..."
              DROPLET_NAME="bn-trading-server"
              DROPLET_INFO=$(curl -s -X GET \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer ${{ secrets.DIGITALOCEAN_TOKEN }}" \
                "https://api.digitalocean.com/v2/droplets?per_page=200" | \
                jq -r ".droplets[] | select(.name==\"$DROPLET_NAME\")" 2>/dev/null)
              
              if [ -n "$DROPLET_INFO" ]; then
                echo "✅ Verified droplet '$DROPLET_NAME' exists in DigitalOcean"
                # Output some details for debugging
                echo "$DROPLET_INFO" | jq -r '.id, .status'
              else
                echo "⚠️ Warning: Could not verify droplet creation through API"
              fi
              break
            else
              echo "❌ Terraform apply failed on attempt $i"
              if [ $i -eq $MAX_ATTEMPTS ]; then
                echo "All $MAX_ATTEMPTS attempts failed, stopping."
                exit 1
              else
                echo "Waiting 60 seconds before next attempt..."
                sleep 60
              fi
            fi
          done

      - name: Set droplet IP output
        id: set_ip
        if: steps.check_existing.outputs.DROPLET_EXISTS != 'true'
        working-directory: infra
        run: |
          # More robust error handling for terraform output
          echo "Attempting to get droplet IP from terraform..."
          
          # First, ensure terraform is working
          if ! terraform version &>/dev/null; then
            echo "Warning: terraform command appears to be unavailable"
            echo "Path: $(which terraform)"
            echo "Directory contents: $(ls -la $(dirname $(which terraform)))"
          fi
          
          # Try accessing terraform state directly as a fallback
          if [ -f terraform.tfstate ]; then
            echo "Found terraform state file, attempting direct extraction..."
            cat terraform.tfstate | grep -o '"droplet_ip"' || echo "No droplet_ip found in state file"
            # Extract IP from terraform.tfstate using jq if available
            if command -v jq &> /dev/null; then
              echo "Using jq to extract IP from state file"
              DIRECT_IP=$(jq -r '.outputs.droplet_ip.value' terraform.tfstate 2>/dev/null)
              if [[ "$DIRECT_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                echo "Successfully extracted IP from state file using jq: $DIRECT_IP"
                echo "DROPLET_IP=$DIRECT_IP" >> $GITHUB_OUTPUT
                exit 0
              else
                echo "Failed to extract valid IP using jq: '$DIRECT_IP'"
              fi
            else
              # Fallback to grep/sed if jq not available
              echo "Jq not available, using grep/sed"
              DIRECT_IP=$(grep -o '"droplet_ip":[[:space:]]*"[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+"' terraform.tfstate | sed 's/"droplet_ip":[[:space:]]*"\([0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+\)"/\1/' || echo "")
              if [[ "$DIRECT_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                echo "Successfully extracted IP from state file using grep/sed: $DIRECT_IP"
                echo "DROPLET_IP=$DIRECT_IP" >> $GITHUB_OUTPUT
                exit 0
              else
                echo "Failed to extract valid IP using grep/sed: '$DIRECT_IP'"
              fi
            fi
          fi
          
          # Approach 1: Using simple output and string capture
          echo "Trying approach 1: simple output capture method..."
          OUT_RAW=$(terraform output 2>/dev/null || echo "")
          echo "$OUT_RAW" | cat -A  # Debug: show all special characters
          
          # Extract with direct pattern matching
          SIMPLE_IP=$(echo "$OUT_RAW" | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+' | head -1)
          if [[ "$SIMPLE_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Successfully extracted IP using simple pattern: $SIMPLE_IP"
            echo "DROPLET_IP=$SIMPLE_IP" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Approach 2: Use terraform output stored in a variable
          echo "Trying approach 2: terraform output with JSON parsing..."
          if command -v jq &> /dev/null; then
            echo "Using jq for parsing..."
            JSON_OUTPUT=$(terraform output -json 2>/dev/null || echo "{}")
            JSON_IP=$(echo "$JSON_OUTPUT" | jq -r '.droplet_ip.value' 2>/dev/null)
            if [[ "$JSON_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "Successfully extracted IP from JSON output: $JSON_IP"
              echo "DROPLET_IP=$JSON_IP" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "Failed to extract valid IP from JSON: '$JSON_IP'"
            fi
          fi
          
          # Approach 3: Save output to a file and then parse it
          echo "Trying approach 3: saving output to file and parsing..."
          terraform output > output.txt
          if [ -f output.txt ]; then
            FILE_CONTENT=$(cat output.txt)
            echo "Output file content:"
            echo "$FILE_CONTENT" | cat -A  # Debug: show all special characters
            
            FILE_IP=$(grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+' output.txt | head -1)
            if [[ "$FILE_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "Successfully extracted IP from file: $FILE_IP"
              echo "DROPLET_IP=$FILE_IP" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # Final desperate attempt - hardcode GitHub output to ensure workflow continues 
          echo "All extraction methods failed, checking if we can see an IP in any output..."
          ALL_IPS=$(grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+' output.txt 2>/dev/null || echo "")
          if [ -n "$ALL_IPS" ]; then
            FIRST_IP=$(echo "$ALL_IPS" | head -1)
            echo "Found an IP in output: $FIRST_IP, using this as fallback"
            echo "DROPLET_IP=$FIRST_IP" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # If we got here, we couldn't extract the IP - report the failure
          echo "Error: Failed to extract IP address from terraform outputs" >&2
          echo "DROPLET_IP=EXTRACTION_FAILED" >> $GITHUB_OUTPUT
          exit 1
      
      # If we found an existing droplet, use its IP
      - name: Use existing droplet IP
        id: use_existing
        if: steps.check_existing.outputs.DROPLET_EXISTS == 'true'
        run: |
          echo "Using existing droplet IP: ${{ steps.check_existing.outputs.DROPLET_IP }}"
          echo "DROPLET_IP=${{ steps.check_existing.outputs.DROPLET_IP }}" >> $GITHUB_OUTPUT

  deploy:
    name: SSH & Deploy Application
    runs-on: ubuntu-latest
    needs: terraform
    env:
      DROPLET_IP: ${{ needs.terraform.outputs.droplet_ip }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Debug droplet IP (env)
        run: |
          echo "DROPLET_IP (from env) is: '$DROPLET_IP'"

      - name: Setup SSH keys
        run: |
          # Install SSH and network tools if not present
          echo "Installing additional diagnostic tools..."
          sudo apt-get update >/dev/null
          sudo apt-get install -y openssh-client netcat-openbsd iputils-ping dnsutils curl traceroute >/dev/null || true
          
          # Create SSH directory and configure permissions
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          
          # Create SSH config file with more permissive settings
          echo "Configuring enhanced SSH settings..."
          cat > ~/.ssh/config << 'EOF'
          Host *
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ServerAliveInterval 60
            ServerAliveCountMax 10
            ConnectTimeout 180
            IdentitiesOnly yes
            LogLevel VERBOSE
            BatchMode yes
            IdentityFile ~/.ssh/id_bn_trading
          EOF
          chmod 600 ~/.ssh/config
          chmod 600 ~/.ssh/config
          
          # Debugging: Show current SSH configuration
          echo "=== SSH config ==="
          cat ~/.ssh/config
          
          # Set up the SSH private key
          echo "Setting up SSH private key..."
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_bn_trading
          chmod 600 ~/.ssh/id_bn_trading
          
          # Verify SSH key format
          echo "Verifying SSH key format..."
          if ! grep -q "BEGIN" ~/.ssh/id_bn_trading && ! grep -q "KEY" ~/.ssh/id_bn_trading; then
            echo "ERROR: SSH key does not appear to be in the correct format!"
            echo "Make sure you have added the PRIVATE key to GitHub secrets, not the public key."
            echo "The key should start with: BEGIN OPENSSH PRIVATE KEY or BEGIN RSA PRIVATE KEY"
            echo "First few characters of current key (redacted for security):"
            head -c 5 ~/.ssh/id_bn_trading
            exit 1
          else
            echo "✅ SSH key appears to be in the correct format"
            echo "Testing SSH key validity..."
            ssh-keygen -y -f ~/.ssh/id_bn_trading > /dev/null && echo "✅ Valid SSH key detected" || {
              echo "❌ Invalid SSH key. Please check the SSH_PRIVATE_KEY secret in your GitHub repository."
              # Save key info for debugging (first line only, no sensitive data)
              head -n 1 ~/.ssh/id_bn_trading
              exit 1
            }
          fi
          
          # Check if key file exists and has correct permissions
          ls -la ~/.ssh/id_bn_trading || { echo "❌ Error: SSH key file not found"; exit 1; }
          
          # Fix permissions if needed
          chmod 600 ~/.ssh/id_bn_trading
          
          # Show SSH key format (just the type, no sensitive data)
          echo "SSH key format: (showing format only)"
          head -n 1 ~/.ssh/id_bn_trading | sed 's/PRIVATE KEY/----- PRIVATE KEY (redacted) -----/'
          
          # Run the SSH config validation script
          echo "Running SSH config validation and fix script..."
          chmod +x ./fix_ssh_config.sh || echo "Failed to make fix_ssh_config.sh executable"
          ./fix_ssh_config.sh || echo "Fix script completed with non-zero exit code"
          
          # Support for both IPv4 and IPv6
          IP_REGEX='^([0-9]{1,3}\.){3}[0-9]{1,3}$|^([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}$'
          
          # Add droplet to known hosts - this ensures the host key is accepted
          if [[ ! "$DROPLET_IP" =~ $IP_REGEX ]]; then
            echo "Warning: Invalid droplet IP format: '$DROPLET_IP', skipping ssh-keyscan"
          else
            echo "Adding host key for $DROPLET_IP"
            # Attempt multiple times with a delay in case the host isn't ready yet
            for i in {1..3}; do
              if ssh-keyscan -H $DROPLET_IP >> ~/.ssh/known_hosts 2>/dev/null; then
                echo "✅ Successfully added host key on attempt $i"
                break
              else
                echo "Warning: ssh-keyscan failed on attempt $i, retrying..."
                sleep 5
              fi
            done
            
            # Try alternative port as fallback
            ssh-keyscan -H -p 2222 $DROPLET_IP >> ~/.ssh/known_hosts 2>/dev/null || echo "Warning: ssh-keyscan on port 2222 failed"
          fi
          
          # Test SSH agent status
          ssh-add -l &>/dev/null
          SSH_ADD_EXIT=$?
          echo "SSH agent status: $SSH_ADD_EXIT (0=with keys, 1=without keys, 2=agent not running)"
          
          # Test if the SSH key is valid
          ssh-keygen -l -f ~/.ssh/id_bn_trading || {
            echo "ERROR: Invalid SSH key format detected!"
            echo "Please verify the SSH_PRIVATE_KEY secret in your GitHub repository."
            exit 1
          }

      - name: Wait for SSH via env var
        run: |
          # Make the IP address visible for debugging
          echo "Trying to connect to IP: '$DROPLET_IP'"
          
          # Exit early if the IP doesn't look valid
          if [[ ! "$DROPLET_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: '$DROPLET_IP' does not appear to be a valid IP address"
            echo "Setting a fallback IP for testing purposes"
            DROPLET_IP="127.0.0.1"
            echo "Will try to use: $DROPLET_IP now for testing connectivity"
          fi
          
          # Enhanced network connectivity check before attempting SSH
          echo "Performing network connectivity checks to $DROPLET_IP:22..."
          for i in {1..3}; do
            echo "Network check attempt $i:"
            # Check if port 22 is reachable
            if nc -z -v -w10 $DROPLET_IP 22 2>&1; then
              echo "✅ Port 22 is reachable!"
              break
            else
              echo "❌ Port 22 is not reachable on attempt $i"
              # Try ping to check basic connectivity
              ping -c 3 $DROPLET_IP || echo "Ping failed"
              # Try traceroute to see network path
              traceroute -m 15 $DROPLET_IP || echo "Traceroute failed"
              sleep 10
            fi
          done
          
          # Attempt SSH connections with better error handling and longer timeout
          MAX_ATTEMPTS=15
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i of $MAX_ATTEMPTS: Testing SSH connection to $DROPLET_IP..."
            
            # Add a delay before first connection attempts to allow server to be fully ready
            if [ $i -eq 1 ]; then
              echo "Waiting 30 seconds for server to be fully ready before first connection attempt..."
              sleep 30
            fi
            
            # Try simple connectivity check with a longer timeout and more verbose output
            if timeout 60 ssh -vvv -o BatchMode=yes -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30 -i ~/.ssh/id_bn_trading root@$DROPLET_IP 'echo "SSH TEST: Connection successful"' 2>&1; then
              echo "✅ SSH connection succeeded on attempt $i!"
              # Verify we can execute commands
              echo "Verifying command execution..."
              if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i ~/.ssh/id_bn_trading root@$DROPLET_IP 'whoami'; then
                echo "✅ Command execution verified!"
                break
              else
                echo "⚠️ Command execution failed, but connection established"
              fi
            else
              echo "❌ Connection attempt $i failed. Details:"
              # More detailed error output with longer timeout and maximum verbosity
              timeout 60 ssh -vvv -o BatchMode=yes -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30 -i ~/.ssh/id_bn_trading root@$DROPLET_IP exit 2>&1 || true
              
              # Check key and permission issues
              echo "Verifying key format and permissions again..."
              ls -la ~/.ssh/id_bn_trading
              ssh-keygen -l -f ~/.ssh/id_bn_trading || echo "Key format verification failed"
              
              # Try alternative port if standard fails
              echo "Trying alternative port 2222..."
              timeout 30 ssh -vvv -p 2222 -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i ~/.ssh/id_bn_trading root@$DROPLET_IP exit 2>&1 || true
            fi
            
            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "⚠️ Warning: SSH not available after $MAX_ATTEMPTS attempts, but continuing anyway"
              echo "Showing SSH key format for debugging:"
              cat ~/.ssh/id_bn_trading | head -n 2
              echo "Checking if port 22 is open:"
              nc -zv $DROPLET_IP 22 || echo "Port 22 appears to be closed or filtered"
            else
              echo "Waiting 20 seconds before next attempt..."
              sleep 20
            fi
          done

      - name: Deploy via SSH
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        run: |
          # Extra validation before deployment
          if [[ ! "$DROPLET_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "ERROR: Cannot deploy - IP address '$DROPLET_IP' is not valid"
            exit 1
          fi
          
          # Run basic TCP port scan to check SSH port accessibility
          echo "Checking if SSH port 22 is open on $DROPLET_IP..."
          if timeout 30 nc -z -v -w5 $DROPLET_IP 22 2>&1; then
            echo "✅ Port 22 is open and accessible"
          else
            echo "⚠️ Warning: Port 22 does not appear to be accessible"
            echo "Trying alternative methods..."
            
            # Try alternative ways to check connectivity
            timeout 5 telnet $DROPLET_IP 22 2>&1 || echo "Telnet test failed"
            
            # Additional diagnostics
            echo "Running traceroute to target host..."
            traceroute -m 15 $DROPLET_IP 2>&1 || echo "Traceroute failed or not available"
            
            echo "Will still attempt SSH deployment but it might fail"
          fi
          
          echo "Attempting to SSH to $DROPLET_IP and deploy application..."
          # Export environment variables that need to be available inside the heredoc
          REPO="${GITHUB_REPOSITORY}"
          USERNAME="${DOCKERHUB_USERNAME}"
          
          # Try with more verbose output and explicit timeout for better diagnostics
          set +e  # Don't exit on error for this command
          # Wait a bit to ensure server is fully ready for deployment commands
          echo "Waiting 15 seconds before attempting deployment..."
          sleep 15
          
          echo "Attempting deployment via SSH with enhanced parameters..."
          ssh -vvv -i ~/.ssh/id_bn_trading -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=30 -o ConnectTimeout=60 -o ConnectionAttempts=3 root@$DROPLET_IP << EOF
            echo "SSH connection successful!"
            # Print system information for debugging
            echo "=== System Information ==="
            uname -a
            ip addr show
            
            # Install Docker Compose if not available
            if ! command -v docker-compose &> /dev/null; then
              echo "Installing Docker Compose..."
              apt-get update
              apt-get install -y docker-compose || {
                echo "Failed to install docker-compose with apt, trying alternative method..."
                curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-\$(uname -s)-\$(uname -m)" -o /usr/local/bin/docker-compose
                chmod +x /usr/local/bin/docker-compose
              }
            fi
            
            # Verify Docker is running
            if ! systemctl is-active --quiet docker; then
              echo "Docker is not running, attempting to start it..."
              systemctl start docker
            fi
            
            # Clone/update repository and deploy
            echo "Cloning or updating repository..."
            cd /bn-trading || { 
              echo "Creating /bn-trading directory..."
              mkdir -p /bn-trading
              git clone https://github.com/$REPO /bn-trading 
              cd /bn-trading 
            }
            
            echo "Using repository: $REPO"
            echo "Using Docker Hub: $USERNAME"
            export DOCKERHUB_USERNAME="$USERNAME"
            
            # Pull the latest changes if directory already exists
            if [ -d .git ]; then
              echo "Repository exists, pulling latest changes..."
              git pull
            fi
            
            # Stop any existing containers
            echo "Stopping any existing containers..."
            docker-compose down || echo "No existing containers to stop"
            
            # Pull the latest images and start the application
            echo "Pulling latest images..."
            docker-compose pull
            
            echo "Starting application containers..."
            docker-compose up -d
            
            # Verify containers are running
            echo "Verifying container status..."
            docker-compose ps
            
            echo "Deployment commands completed"
          EOF
          SSH_EXIT=$?
          
          if [ $SSH_EXIT -ne 0 ]; then
            echo "⚠️ Warning: SSH deployment exited with code $SSH_EXIT"
            echo "This might be a temporary issue, checking application status..."
          else
            echo "✅ SSH deployment completed successfully!"
          fi

      - name: Verify Deployment
        run: |
          echo "Waiting for application to start up (30 seconds)..."
          sleep 30
          
          echo "Checking application health endpoint..."
          # Try multiple verification methods
          set +e  # Don't exit on error initially
          
          # Method 1: Check main endpoint
          echo "Method 1: Testing main application endpoint..."
          RESPONSE=$(curl -s -m 15 http://$DROPLET_IP:5000/ || echo "Connection failed")
          
          if echo "$RESPONSE" | grep -q "Bank Nifty Trading"; then
            echo "✅ Main application endpoint verified"
            VERIFIED=true
          else
            echo "❌ Main application endpoint verification failed"
            echo "Response received: ${RESPONSE:0:100}..."
          fi
          
          # Method 2: Check health endpoint
          echo "Method 2: Testing health endpoint..."
          HEALTH=$(curl -s -m 10 http://$DROPLET_IP:5000/health || echo "Connection failed")
          
          if echo "$HEALTH" | grep -q "healthy"; then
            echo "✅ Health endpoint verified"
            VERIFIED=true
          else
            echo "❌ Health endpoint verification failed"
            echo "Response received: ${HEALTH:0:100}..."
          fi
          
          # Method 3: Check container status directly
          echo "Method 3: Checking container status via SSH..."
          ssh -vvv -i ~/.ssh/id_bn_trading -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=30 -o ConnectTimeout=30 -o ConnectionAttempts=3 root@$DROPLET_IP << EOF || echo "SSH container check failed"
            echo "Checking Docker containers..."
            docker ps | grep -i trading && echo "✅ Trading container is running" || echo "❌ Trading container not found"
            
            echo "Container logs (last 10 lines):"
            docker-compose -f /bn-trading/docker-compose.yml logs --tail=10
          EOF
          
          # Final verification decision
          if [ "$VERIFIED" == "true" ]; then
            echo "✅ Deployment verified via at least one method"
          else
            echo "🚨 Deployment verification failed on all methods"
            
            # One final attempt with verbose output
            echo "Final diagnostic check with verbose output:"
            curl -v --max-time 20 http://$DROPLET_IP:5000/
            
            # Continue anyway to avoid breaking the workflow
            echo "⚠️ Continuing despite verification failure"
            # exit 1 # Uncomment if you want to fail the workflow on verification failure
          fi
          
      - name: Run additional diagnostics if SSH fails
        if: failure()
        run: |
          # Make diagnostic scripts executable
          chmod +x ./network_diagnostics.sh ./ssh_diagnostics.sh ./enhanced_ssh_diagnostics.sh || echo "Could not make scripts executable"
          
          echo "===== RUNNING EXTENDED DIAGNOSTICS ====="
          
          # Run the new enhanced SSH diagnostics first
          if [ -f "./enhanced_ssh_diagnostics.sh" ]; then
            echo "Running enhanced SSH connection diagnostics..."
            ./enhanced_ssh_diagnostics.sh "$DROPLET_IP" || echo "Enhanced SSH diagnostics failed but continuing"
          else
            echo "Enhanced SSH diagnostics script not found."
          fi
          
          # Run original network diagnostics
          if [ -f "./network_diagnostics.sh" ]; then
            echo "Running comprehensive network diagnostics..."
            ./network_diagnostics.sh || echo "Network diagnostics failed but continuing"
          else
            echo "Network diagnostics script not found."
          fi
          
          # Run original SSH diagnostics
          if [ -f "./ssh_diagnostics.sh" ]; then
            echo "Running comprehensive SSH diagnostics..."
            ./ssh_diagnostics.sh "$DROPLET_IP" || echo "SSH diagnostics failed but continuing"
          else
            echo "SSH diagnostics script not found."
          fi
          
          # Try direct DO API lookup
          echo "Checking droplet status via DigitalOcean API..."
          if [ -n "$DIGITALOCEAN_TOKEN" ]; then
            curl -s -X GET \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $DIGITALOCEAN_TOKEN" \
              "https://api.digitalocean.com/v2/droplets?per_page=200" | \
              grep -A 15 -B 5 "$DROPLET_IP" || echo "Could not find droplet in DO API"
          else
            echo "DIGITALOCEAN_TOKEN not set, skipping API check"
          fi
          
          echo "Diagnostics completed. Check the logs for more information."

      - name: Count Existing Droplets
        if: always()
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}
        run: |
          echo "Checking for other bn-trading-server droplets..."
          DROPLET_COUNT=$(curl -s -X GET \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $DIGITALOCEAN_TOKEN" \
            "https://api.digitalocean.com/v2/droplets?per_page=200" | \
            jq -r '.droplets[] | select(.name=="bn-trading-server")' | wc -l)
          
          echo "Found $DROPLET_COUNT droplets with name 'bn-trading-server'"
          if [ "$DROPLET_COUNT" -gt 3 ]; then
            echo "⚠️ Warning: You have $DROPLET_COUNT bn-trading-server droplets."
            echo "Consider cleaning up old droplets using the cleanup_droplets.sh script."
          fi