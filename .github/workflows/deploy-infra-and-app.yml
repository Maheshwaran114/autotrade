name: Provision & Deploy to DO

on:
  push:
    branches:
      - main

jobs:
  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          version: latest
      
      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v3
        with:
          context: .
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/bn-trading:latest
          cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/bn-trading:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/bn-trading:buildcache,mode=max

  terraform:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: build
    outputs:
      droplet_ip: ${{ steps.set_ip.outputs.DROPLET_IP }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Perform network diagnostics
        run: |
          echo "Running network diagnostics..."
          echo "DNS Servers:"
          cat /etc/resolv.conf
          
          echo "Testing connectivity to api.digitalocean.com:"
          ping -c 3 api.digitalocean.com || echo "Ping failed but continuing"
          
          echo "Testing DNS resolution:"
          nslookup api.digitalocean.com || echo "DNS lookup failed but continuing"
          
          echo "Testing HTTPS connectivity:"
          curl -sSL https://api.digitalocean.com/v2/account -o /dev/null -w "Response code: %{http_code}\n" || echo "HTTPS test failed but continuing"
          
          echo "Checking for proxy settings:"
          env | grep -i proxy || echo "No proxy settings found"
      
      - name: Terraform Init
        working-directory: infra
        run: |
          # Retry logic for terraform init
          MAX_ATTEMPTS=3
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i/$MAX_ATTEMPTS: Running terraform init..."
            if terraform init; then
              echo "‚úÖ Terraform init succeeded!"
              break
            else
              echo "‚ùå Terraform init failed on attempt $i"
              if [ $i -eq $MAX_ATTEMPTS ]; then
                echo "All $MAX_ATTEMPTS attempts failed, stopping."
                exit 1
              else
                echo "Waiting 30 seconds before next attempt..."
                sleep 30
              fi
            fi
          done

      - name: Terraform Validate
        working-directory: infra
        run: |
          # Retry logic for terraform validate
          MAX_ATTEMPTS=3
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i/$MAX_ATTEMPTS: Running terraform validate..."
            if terraform validate; then
              echo "‚úÖ Terraform validate succeeded!"
              break
            else
              echo "‚ùå Terraform validate failed on attempt $i"
              if [ $i -eq $MAX_ATTEMPTS ]; then
                echo "All $MAX_ATTEMPTS attempts failed, stopping."
                exit 1
              else
                echo "Waiting 10 seconds before next attempt..."
                sleep 10
              fi
            fi
          done

      - name: Check for existing droplet
        id: check_existing
        working-directory: infra
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}
        run: |
          # Check if there's already a droplet with our target name
          echo "Checking for existing droplet with name 'bn-trading-server'..."
          EXISTING_DROPLETS=$(curl -s -X GET \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $DIGITALOCEAN_TOKEN" \
            "https://api.digitalocean.com/v2/droplets?per_page=200" | \
            jq -r '.droplets[] | select(.name=="bn-trading-server")')
          
          if [ -n "$EXISTING_DROPLETS" ]; then
            # Get the first droplet if multiple exist
            echo "Found existing droplets with name 'bn-trading-server'. Using the first one."
            FIRST_DROPLET=$(echo "$EXISTING_DROPLETS" | head -n 1)
            DROPLET_ID=$(echo "$FIRST_DROPLET" | jq -r '.id')
            DROPLET_IP=$(echo "$FIRST_DROPLET" | jq -r '.networks.v4[] | select(.type=="public") | .ip_address' | head -n 1)
            
            echo "Selected droplet: ID=$DROPLET_ID, IP=$DROPLET_IP"
            echo "DROPLET_EXISTS=true" >> $GITHUB_OUTPUT
            echo "DROPLET_IP=$DROPLET_IP" >> $GITHUB_OUTPUT
            echo "DROPLET_ID=$DROPLET_ID" >> $GITHUB_OUTPUT
            
            # List all found droplets for information
            echo "All matching droplets:"
            echo "$EXISTING_DROPLETS" | jq -r '.id'
          else
            echo "No existing droplet found with name 'bn-trading-server'"
            echo "DROPLET_EXISTS=false" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Apply
        id: apply
        working-directory: infra
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}
        if: steps.check_existing.outputs.DROPLET_EXISTS != 'true'
        run: |
          # Configure SSH known hosts to avoid trust issues
          mkdir -p ~/.ssh
          ssh-keyscan -H digitalocean.com >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Set DNS servers explicitly if needed
          if ! ping -c 1 api.digitalocean.com &>/dev/null; then
            echo "Primary DNS checks failed, trying Google DNS..."
            echo "nameserver 8.8.8.8" | sudo tee /etc/resolv.conf > /dev/null
            echo "nameserver 8.8.4.4" | sudo tee -a /etc/resolv.conf > /dev/null
          fi
          
          echo "Starting Terraform apply with retry logic..."
          MAX_ATTEMPTS=3
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i/$MAX_ATTEMPTS: Running terraform apply..."
            if terraform apply -auto-approve -var="digitalocean_token=${{ secrets.DIGITALOCEAN_TOKEN }}" -var="ssh_key_id=${{ secrets.SSH_KEY_ID }}"; then
              echo "‚úÖ Terraform apply succeeded!"
              break
            else
              echo "‚ùå Terraform apply failed on attempt $i"
              if [ $i -eq $MAX_ATTEMPTS ]; then
                echo "All $MAX_ATTEMPTS attempts failed, stopping."
                exit 1
              else
                echo "Waiting 60 seconds before next attempt..."
                sleep 60
              fi
            fi
          done

      - name: Set droplet IP output
        id: set_ip
        if: steps.check_existing.outputs.DROPLET_EXISTS != 'true'
        working-directory: infra
        run: |
          # More robust error handling for terraform output
          echo "Attempting to get droplet IP from terraform..."
          
          # First, ensure terraform is working
          if ! terraform version &>/dev/null; then
            echo "Warning: terraform command appears to be unavailable"
            echo "Path: $(which terraform)"
            echo "Directory contents: $(ls -la $(dirname $(which terraform)))"
          fi
          
          # Try accessing terraform state directly as a fallback
          if [ -f terraform.tfstate ]; then
            echo "Found terraform state file, attempting direct extraction..."
            cat terraform.tfstate | grep -o '"droplet_ip"' || echo "No droplet_ip found in state file"
            # Extract IP from terraform.tfstate using jq if available
            if command -v jq &> /dev/null; then
              echo "Using jq to extract IP from state file"
              DIRECT_IP=$(jq -r '.outputs.droplet_ip.value' terraform.tfstate 2>/dev/null)
              if [[ "$DIRECT_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                echo "Successfully extracted IP from state file using jq: $DIRECT_IP"
                echo "DROPLET_IP=$DIRECT_IP" >> $GITHUB_OUTPUT
                exit 0
              else
                echo "Failed to extract valid IP using jq: '$DIRECT_IP'"
              fi
            else
              # Fallback to grep/sed if jq not available
              echo "Jq not available, using grep/sed"
              DIRECT_IP=$(grep -o '"droplet_ip":[[:space:]]*"[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+"' terraform.tfstate | sed 's/"droplet_ip":[[:space:]]*"\([0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+\)"/\1/' || echo "")
              if [[ "$DIRECT_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                echo "Successfully extracted IP from state file using grep/sed: $DIRECT_IP"
                echo "DROPLET_IP=$DIRECT_IP" >> $GITHUB_OUTPUT
                exit 0
              else
                echo "Failed to extract valid IP using grep/sed: '$DIRECT_IP'"
              fi
            fi
          fi
          
          # Approach 1: Using simple output and string capture
          echo "Trying approach 1: simple output capture method..."
          OUT_RAW=$(terraform output 2>/dev/null || echo "")
          echo "$OUT_RAW" | cat -A  # Debug: show all special characters
          
          # Extract with direct pattern matching
          SIMPLE_IP=$(echo "$OUT_RAW" | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+' | head -1)
          if [[ "$SIMPLE_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Successfully extracted IP using simple pattern: $SIMPLE_IP"
            echo "DROPLET_IP=$SIMPLE_IP" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Approach 2: Use terraform output stored in a variable
          echo "Trying approach 2: terraform output with JSON parsing..."
          if command -v jq &> /dev/null; then
            echo "Using jq for parsing..."
            JSON_OUTPUT=$(terraform output -json 2>/dev/null || echo "{}")
            JSON_IP=$(echo "$JSON_OUTPUT" | jq -r '.droplet_ip.value' 2>/dev/null)
            if [[ "$JSON_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "Successfully extracted IP from JSON output: $JSON_IP"
              echo "DROPLET_IP=$JSON_IP" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "Failed to extract valid IP from JSON: '$JSON_IP'"
            fi
          fi
          
          # Approach 3: Save output to a file and then parse it
          echo "Trying approach 3: saving output to file and parsing..."
          terraform output > output.txt
          if [ -f output.txt ]; then
            FILE_CONTENT=$(cat output.txt)
            echo "Output file content:"
            echo "$FILE_CONTENT" | cat -A  # Debug: show all special characters
            
            FILE_IP=$(grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+' output.txt | head -1)
            if [[ "$FILE_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "Successfully extracted IP from file: $FILE_IP"
              echo "DROPLET_IP=$FILE_IP" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # Final desperate attempt - hardcode GitHub output to ensure workflow continues 
          echo "All extraction methods failed, checking if we can see an IP in any output..."
          ALL_IPS=$(grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+' output.txt 2>/dev/null || echo "")
          if [ -n "$ALL_IPS" ]; then
            FIRST_IP=$(echo "$ALL_IPS" | head -1)
            echo "Found an IP in output: $FIRST_IP, using this as fallback"
            echo "DROPLET_IP=$FIRST_IP" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # If we got here, we couldn't extract the IP - report the failure
          echo "Error: Failed to extract IP address from terraform outputs" >&2
          echo "DROPLET_IP=EXTRACTION_FAILED" >> $GITHUB_OUTPUT
          exit 1
      
      # If we found an existing droplet, use its IP
      - name: Use existing droplet IP
        id: use_existing
        if: steps.check_existing.outputs.DROPLET_EXISTS == 'true'
        run: |
          echo "Using existing droplet IP: ${{ steps.check_existing.outputs.DROPLET_IP }}"
          echo "DROPLET_IP=${{ steps.check_existing.outputs.DROPLET_IP }}" >> $GITHUB_OUTPUT

  deploy:
    name: SSH & Deploy Application
    runs-on: ubuntu-latest
    needs: terraform
    env:
      DROPLET_IP: ${{ needs.terraform.outputs.droplet_ip }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Debug droplet IP (env)
        run: |
          echo "DROPLET_IP (from env) is: '$DROPLET_IP'"

      - name: Setup SSH keys
        run: |
          sudo apt-get update && sudo apt-get install -y openssh-client
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          echo "Host *\n  StrictHostKeyChecking no\n  UserKnownHostsFile /dev/null" > ~/.ssh/config
          chmod 600 ~/.ssh/config
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H $DROPLET_IP >> ~/.ssh/known_hosts

      - name: Wait for SSH via env var
        run: |
          # Make the IP address visible for debugging
          echo "Trying to connect to IP: '$DROPLET_IP'"
          
          # Exit early if the IP doesn't look valid
          if [[ ! "$DROPLET_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: '$DROPLET_IP' does not appear to be a valid IP address"
            echo "Setting a test IP for debugging purposes"
            DROPLET_IP="127.0.0.1"
            echo "Will try to use: $DROPLET_IP now"
          fi
          
          # Attempt SSH connections with better error handling
          MAX_ATTEMPTS=10
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i of $MAX_ATTEMPTS: Testing SSH connection to $DROPLET_IP..."
            if timeout 10 ssh -v -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=5 -i ~/.ssh/id_rsa root@$DROPLET_IP 'echo "SSH TEST: Connection successful"' 2>&1; then
              echo "‚úÖ SSH connection succeeded on attempt $i!"
              break
            else
              echo "‚ùå Connection attempt $i failed. Details:"
              timeout 10 ssh -v -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=5 -i ~/.ssh/id_rsa root@$DROPLET_IP exit 2>&1 || true
            fi
            
            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "‚ö†Ô∏è Warning: SSH not available after $MAX_ATTEMPTS attempts, but continuing anyway"
              echo "Showing SSH key format for debugging:"
              cat ~/.ssh/id_rsa | head -n 2
            else
              echo "Waiting 10 seconds before next attempt..."
              sleep 10
            fi
          done

      - name: Deploy via SSH
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        run: |
          # Extra validation before deployment
          if [[ ! "$DROPLET_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "ERROR: Cannot deploy - IP address '$DROPLET_IP' is not valid"
            exit 1
          fi
          
          echo "Attempting to SSH to $DROPLET_IP and deploy application..."
          # Export environment variables that need to be available inside the heredoc
          REPO="${GITHUB_REPOSITORY}"
          USERNAME="${DOCKERHUB_USERNAME}"
          
          ssh -v -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no root@$DROPLET_IP << EOF
            echo "SSH connection successful!"
            # Install Docker Compose if not available
            if ! command -v docker-compose &> /dev/null; then
              echo "Installing Docker Compose..."
              apt-get update
              apt-get install -y docker-compose
            fi
            
            cd /bn-trading || { git clone https://github.com/$REPO /bn-trading; cd /bn-trading; }
            echo "Using repository: $REPO"
            echo "Using Docker Hub: $USERNAME"
            export DOCKERHUB_USERNAME="$USERNAME"
            docker-compose down || true
            docker-compose pull
            docker-compose up -d
            echo "Deployment commands completed"
          EOF

      - name: Verify Deployment
        run: |
          sleep 20
          RESPONSE=$(curl -s --max-time 10 http://$DROPLET_IP:5000/)
          if echo "$RESPONSE" | grep -q "Bank Nifty Trading"; then
            echo "‚úÖ Deployment verified"
          else
            echo "üö® Deployment verification failed" && exit 1
          fi
          
      - name: Count Existing Droplets
        if: success()
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}
        run: |
          echo "Checking for other bn-trading-server droplets..."
          DROPLET_COUNT=$(curl -s -X GET \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $DIGITALOCEAN_TOKEN" \
            "https://api.digitalocean.com/v2/droplets?per_page=200" | \
            jq -r '.droplets[] | select(.name=="bn-trading-server")' | wc -l)
          
          echo "Found $DROPLET_COUNT droplets with name 'bn-trading-server'"
          if [ "$DROPLET_COUNT" -gt 3 ]; then
            echo "‚ö†Ô∏è Warning: You have $DROPLET_COUNT bn-trading-server droplets."
            echo "Consider cleaning up old droplets using the cleanup_droplets.sh script."
          fi