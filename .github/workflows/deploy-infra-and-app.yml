name: Provision & Deploy to DO

on:
  push:
    branches:
      - main

jobs:
  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          version: latest
      
      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v3
        with:
          context: .
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/bn-trading:latest
          cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/bn-trading:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/bn-trading:buildcache,mode=max

  terraform:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: build
    outputs:
      droplet_ip: ${{ steps.tf_output.outputs.DROPLET_IP }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Terraform Init
        working-directory: infra
        run: terraform init

      - name: Terraform Validate
        working-directory: infra
        run: terraform validate

      - name: Terraform Apply
        working-directory: infra
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}
        run: |
          # First check if droplet already exists to avoid hitting limits
          echo "Checking for existing droplets..."
          
          # Check if terraform state already has the resources
          if terraform state list 2>/dev/null | grep -q "digitalocean_droplet.bn-trading"; then
            echo "Droplet already exists in Terraform state. Running apply to ensure configuration is up to date."
            terraform apply -auto-approve -var="digitalocean_token=${{ secrets.DIGITALOCEAN_TOKEN }}" -var="ssh_key_id=${{ secrets.SSH_KEY_ID }}" -var="create_floating_ip=false"
          else
            # Check DigitalOcean API directly for a droplet with our name
            EXISTING_DROPLET=$(curl -s -X GET \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $DIGITALOCEAN_TOKEN" \
              "https://api.digitalocean.com/v2/droplets?per_page=200" | 
              grep -o '"name":"bn-trading-server"' || echo "")
            
            if [ -n "$EXISTING_DROPLET" ]; then
              echo "Found existing droplet with name 'bn-trading-server'. Importing into Terraform state..."
              # Get droplet ID
              DROPLET_ID=$(curl -s -X GET \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer $DIGITALOCEAN_TOKEN" \
                "https://api.digitalocean.com/v2/droplets?per_page=200" | 
                grep -o '"name":"bn-trading-server".*?[0-9]*' | 
                grep -o '[0-9]*' | head -1)
              
              if [ -n "$DROPLET_ID" ]; then
                echo "Importing droplet with ID: $DROPLET_ID"
                terraform import digitalocean_droplet.bn-trading $DROPLET_ID || true
                
                # Now run apply to ensure configuration matches
                terraform apply -auto-approve -var="digitalocean_token=${{ secrets.DIGITALOCEAN_TOKEN }}" -var="ssh_key_id=${{ secrets.SSH_KEY_ID }}" -var="create_floating_ip=false"
              else
                echo "WARNING: Could not retrieve droplet ID. Proceeding with normal apply."
                terraform apply -auto-approve -var="digitalocean_token=${{ secrets.DIGITALOCEAN_TOKEN }}" -var="ssh_key_id=${{ secrets.SSH_KEY_ID }}" -var="create_floating_ip=false"
              fi
            else
              echo "No existing droplet found. Proceeding with normal apply."
              terraform apply -auto-approve -var="digitalocean_token=${{ secrets.DIGITALOCEAN_TOKEN }}" -var="ssh_key_id=${{ secrets.SSH_KEY_ID }}" -var="create_floating_ip=false"
            fi
          fi

      - name: Output Infrastructure IPs
        working-directory: infra
        id: ip_extract
        run: |
          # Capture all terraform outputs in a structured format
          echo "Getting Terraform outputs..."
          
          # First, create a file to store the raw outputs
          terraform output > terraform_outputs.txt
          cat terraform_outputs.txt
          
          # Extract floating IP from the output file using regex to get just the IP
          echo "Extracting floating IP..."
          FLOATING_IP=$(grep -oE "floating_ip = \"[0-9\.]+\"" terraform_outputs.txt | grep -oE "[0-9\.]+" || echo "")
          
          # If floating IP not found, try to extract droplet IP
          if [ -z "$FLOATING_IP" ]; then
            echo "Floating IP not found, extracting droplet IP..."
            FLOATING_IP=$(grep -oE "droplet_ip = \"[0-9\.]+\"" terraform_outputs.txt | grep -oE "[0-9\.]+" || echo "")
          fi
          
          # If still no IP found, try other methods
          if [ -z "$FLOATING_IP" ]; then
            echo "Trying alternate extraction method..."
            # Extract IP using direct terraform output but clean the result by filtering for IP pattern
            TEMP_OUTPUT=$(terraform output -raw floating_ip 2>/dev/null || echo "")
            FLOATING_IP=$(echo "$TEMP_OUTPUT" | grep -oE "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" | head -1 || echo "")
            
            # If still no floating IP, try with droplet IP
            if [ -z "$FLOATING_IP" ]; then
              TEMP_OUTPUT=$(terraform output -raw droplet_ip 2>/dev/null || echo "")
              FLOATING_IP=$(echo "$TEMP_OUTPUT" | grep -oE "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" | head -1 || echo "")
            fi
          fi
          
          # Clean up the IP address - ensure it's only one line with no extra characters
          FLOATING_IP=$(echo "$FLOATING_IP" | head -n 1 | tr -d '\n\r ')
          
          # For debugging, show what we found
          echo "Extracted IP address: '$FLOATING_IP'"
          
          # Export the IP value to be used in a separate step
          echo "IP_VALUE=$FLOATING_IP" >> $GITHUB_ENV
          
          if [ -z "$FLOATING_IP" ]; then
            echo "ERROR: Could not extract any IP address from Terraform outputs"
            echo "Showing terraform state for debugging..."
            terraform show
            exit 1
          else
            echo "Successfully captured IP: $FLOATING_IP"
          fi
      
      # Separate step for setting the output to avoid GitHub Actions output issues
      - name: Set output value
        id: tf_output
        run: echo "DROPLET_IP=${{ env.IP_VALUE }}" >> $GITHUB_OUTPUT

  deploy:
    name: SSH & Deploy Application
    runs-on: ubuntu-latest
    needs: terraform
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3
      
      - name: Wait for droplet to be ready
        run: |
          echo "Waiting for system to be ready at ${{ needs.terraform.outputs.droplet_ip }}..."
          # Loop with a timeout of 5 minutes (30 x 10 seconds)
          for i in {1..30}; do
            if nc -z -w 5 ${{ needs.terraform.outputs.droplet_ip }} 22; then
              echo "SSH port is open!"
              # Give the system a bit more time to fully initialize
              sleep 30
              break
            fi
            echo "Attempt $i: Waiting for SSH to be available..." 
            sleep 10
            if [ $i -eq 30 ]; then
              echo "Error: Timed out waiting for SSH connection"
              exit 1
            fi
          done

      - name: Add SSH key
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          known_hosts: "unnecessary"

      - name: Add DigitalOcean droplet to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ needs.terraform.outputs.droplet_ip }} >> ~/.ssh/known_hosts

      - name: Setup Server and Deploy Application
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        run: |
          ssh -o StrictHostKeyChecking=accept-new root@${{ needs.terraform.outputs.droplet_ip }} << EOF
            echo "Setting up server environment..."
            # Update package lists
            apt-get update
            
            # Ensure Docker and Docker Compose are installed
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              apt-get install -y \
                apt-transport-https \
                ca-certificates \
                curl \
                gnupg \
                lsb-release
              
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
              
              echo \
                "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
                \$(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
              
              apt-get update
              apt-get install -y docker-ce docker-ce-cli containerd.io
            fi
            
            if ! command -v docker-compose &> /dev/null; then
              echo "Installing Docker Compose..."
              curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-\$(uname -s)-\$(uname -m)" -o /usr/local/bin/docker-compose
              chmod +x /usr/local/bin/docker-compose
            fi
            
            # Install required utilities
            apt-get install -y curl jq
            
            # Clone or update the repository
            REPO="${GITHUB_REPOSITORY}"
            if [ -d /bn-trading ]; then
              echo "Updating existing repository..."
              cd /bn-trading && git pull origin main
            else
              echo "Cloning repository..."
              git clone https://github.com/\${REPO} /bn-trading
            fi
            
            # Deploy with Docker Compose
            cd /bn-trading
            echo "Starting application with Docker Compose..."
            export DOCKERHUB_USERNAME="${DOCKERHUB_USERNAME}"
            docker-compose down || true
            docker-compose pull
            docker-compose up -d
            
            # Check if containers are running
            echo "Checking deployment status..."
            if docker-compose ps | grep -q "Up"; then
              echo "Deployment successful - containers are running"
              
              # Wait for the application to be fully operational
              echo "Waiting for application to initialize..."
              HEALTH_CHECK_ATTEMPTS=0
              MAX_ATTEMPTS=10
              
              while [ \$HEALTH_CHECK_ATTEMPTS -lt \$MAX_ATTEMPTS ]; do
                if curl -s --max-time 5 http://localhost:5000/health | grep -q "ok"; then
                  echo "✅ Health check passed: Application is fully operational"
                  break
                fi
                
                echo "Health check attempt \$((HEALTH_CHECK_ATTEMPTS+1))/\$MAX_ATTEMPTS: Waiting for application to be ready..."
                HEALTH_CHECK_ATTEMPTS=\$((HEALTH_CHECK_ATTEMPTS+1))
                sleep 5
                
                # If we've reached max attempts, show warning but don't fail
                if [ \$HEALTH_CHECK_ATTEMPTS -eq \$MAX_ATTEMPTS ]; then
                  echo "⚠️ Warning: Health check did not pass within expected time."
                  echo "Application containers are running, but health check endpoint isn't responding."
                  echo "This might indicate an application initialization issue."
                fi
              done
            else
              echo "ERROR: Deployment failed - containers are not running"
              docker-compose logs
              exit 1
            fi
          EOF

      - name: Verify Deployment
        run: |
          echo "Verifying deployment by checking the application endpoint..."
          # Give the application a moment to start
          sleep 20
          # Try to connect to the app endpoint
          curl_attempt=0
          max_attempts=6
          
          while [ $curl_attempt -lt $max_attempts ]; do
            echo "Attempt $((curl_attempt+1))/$max_attempts: Checking application endpoint..."
            
            # Show the actual response for debugging
            RESPONSE=$(curl -s --max-time 10 http://${{ needs.terraform.outputs.droplet_ip }}:5000/)
            echo "Response: $RESPONSE"
            
            if echo "$RESPONSE" | grep -q "Bank Nifty Trading"; then
              echo "✅ Application is responding properly!"
              exit 0
            fi
            
            echo "Attempt $((curl_attempt+1))/$max_attempts: Application not responding with expected content yet..."
            curl_attempt=$((curl_attempt+1))
            sleep 10
          done
          
          echo "⚠️ Warning: Could not verify application deployment after multiple attempts."
          echo "Please check the logs on the server manually with:"
          echo "ssh root@${{ needs.terraform.outputs.droplet_ip }} 'cd /bn-trading && docker-compose logs'"
          # Don't fail the workflow, but provide warning
